# Java Socket 프로그래밍

## 기본

1. 소켓을 기반으로 한다.
2. 네트워크로 연결된 둘 이상의 컴퓨터 사이에서의 데이터 송수신 프로그램 작성 의미

## 소켓

1. 네트워크 연결 도구
2. 운영체제에 의헤 제공되는 소프트웨어 장치
3. 프로그래머에게 데이터 송수신에 대한 물리적, 소프트웨어적 세세한 신경을 쓰지 않게 한다.
4. TCP 소켓은 전화기에 비유
5. 프로세스 간의 통신에 사용되는 양쪽 끝을 의미
6. TCP/IP 프로토콜에 포함된 프로토콜로써 OSI 7계층에 해당한다.

## TCP

1. 연결 지향형 프로토콜
2. 데이터의 경계가 없다.
3. 전화(받았는지, 못받았는지 확인이 가능하다.)
4. UDP에 비해 전송 속도가 느리다.
5. 서버 소켓과 클라이언트 소켓의 구분이 있다.
6. 전송 순서대로 데이터가 수신된다.
7. 중간에 데이터가 소멸되지 않는다.
8. 소켓대 소켓은 1대1 연결 구조

## UDP

1. 비 연결 지향향 프로토콜
2. 데이터의 경계가 있다.
3. 우편(받았는지, 못받았는지 확인이 불가능하다.)
4. TCP에 비해 전송 속도가 빠르다.
5. 서버 소켓과 클라이언트 소켓의 구분이 없다. 즉 1개만 있으면 된다.
6. 전송 순서와 상관없다.
7. 데이터 손실 및 파손의 우려가 있다.
8. 한번에 보낼 수 있는 데이터의 크기가 제한된다.

## TCP 소켓 프로그래밍

1. InputStream, OutputStream을 가지고 있다. 이 두 스트림을 통해 프로세스간 통신(입출력)이 이루어 진다.
2. ServerSocket : 포트와 bind되어 외부의 연결요청을 기다린다. 연결 요청이 들어오면 Socket를 생성해서 소켓과 소켓간의 통신이 이루어지도록 한다.
3. 한 포트의 하나의 ServerSocket만 연결할 수 있다. (프로토콜이 다르면 같은 포트를 사용할 수 있다.)

## 순서

1. 서버는 서버소켓을 사용해서 서버 컴퓨터의 특정 포트에서 클라이언트의 연결요청을 처리할 준비를 한다.
2. 클라이언트는 접속할 서버의 IP주소와 포트정보로 소켓을 생성해서 서버에 연결을 요청한다.
3. 서버소켓은 클라이언트의 요청을 받으면 서버에 새로운 소켓을 생성해서 클라이언트의 소켓과 연결되도록 한다.
4. 클라이언트의 소켓과 새로 생성된 서버의 소켓은 서버 소켓과 관계없이 1:1통신을 한다.

## Stream

- 네트워크에서 가장 큰 비중을 차지하는 것이 입출력(I/O)이다.
- 입출력(I/O)는 하나의 시스템에서 다른 시스템으로 데이터를 이동하는 일이다.
- 자바의 I/O는 Stream(스트림)에 내장되어 있다.
- 입력 스트림은 데이터를 읽고, 출력 스트림은 데이터를 쓴다.
- 필터 스트림은 입, 출력 스트임에 연결될 수 있다.
- 필터는 읽거나 쓰는 데이터를 수정하는데 사용한다. 데이터 암호화, 압축, 다른 포멧으로 변환
- 스트림은 동기(Synchronous)로 동작한다.
- 프로그램(실제는 Thread)이 데이터를 읽거나 쓰기 위해 스트림에 요청하면, 스트림은 다른 작업을 수행하기 전에 데이터를 읽거나 쓸 수 있을 때 까지 기다린다.
- 자바는 Channel, Buffer를 사용한 Non Block I/O를 제공한다.
- TCP/IP 구현은 어느 정도 데이터를 버퍼링하여 전송한다. 즉 TCP/IP는 메모리에 데이터를 쌓아 두고, 일정 수치에 도달하거나 특정 시간을 초과할 경우 데이터를 전송한다.
- 출력 스트림은 버퍼가 가득 차지 않으면 버퍼 안의 데이터를 전송하지 않고 기다린다. 데드락 상태가 발생할 수 있다.
- flush() 메소드는 버퍼가 아직 가득 차지 않은 상황에서 강제로 버퍼의 내용을 전송함으로써 데드락 상태를 해제한다.
- 스트림 사용이 끝나면 close를 통해 스트림을 닫는다.

## Thread

- 콜백이 폴링 방식보다 좋은 이유
- CPU 시간을 낭비하지 않는다.
- 콜백방식이 좀 더 유연하며, 많은 스레드와 객체, 클래스가 엮여 있는 복잡한 상황에 충분히 대처 할 수 있다.
- 스레드는 객체를 목록으로 관리하여 콜백을 호출할 수 있다.
- 계산 결과가 필요한 객체는 Thread, Runnable 클래스의 메소드를 호출하여 자신을 등록할 수 있다.

## ExecutorService

- 스레드를 직접 생성하지 않고 필요할 때 Thread를 생성하여 제공
- 자바 5에서 새로 추가된 방법
- 작업 대상의 Callable 객체를 만들고 ExecutorService에 등록한 다음 Feture 객체를 반환받는다.
- 나중에 작업에 대한 결과를 Feture를 통해 얻는다.
- Feture사용시 이미 결과가 있는 경우 즉시 결과 값을 구할 수 있지만, 그렇지 않은 경우 폴링 스레드는 준비가 될 때까지 블록된다.

## 구성

* Simplex Tcp Server
* Half Duplex Tcp Server
* Echo Tcp Server
* Thread pool Tcp Server

-----

* Iterative Tcp Server
* UDP Server 
* FTP Server

## 출처

* http://gangzzang.tistory.com/entry/Java-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
* http://nowonbun.tistory.com/315

* http://jdm.kr/blog/154
* https://github.com/bghgu/TCP-IP
* https://github.com/bghgu/CS/tree/master/Network%20Programming


